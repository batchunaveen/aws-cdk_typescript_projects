"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api = require("@aws-cdk/cx-api");
const assertion_1 = require("./assertion");
const match_template_1 = require("./assertions/match-template");
class Inspector {
    constructor() {
        this.aroundAssert = undefined;
    }
    to(assertion) {
        return this.aroundAssert ? this.aroundAssert(() => this._to(assertion))
            : this._to(assertion);
    }
    notTo(assertion) {
        return this.to(assertion_1.not(assertion));
    }
    _to(assertion) {
        assertion.assertOrThrow(this);
    }
}
exports.Inspector = Inspector;
class StackInspector extends Inspector {
    constructor(stack) {
        super();
        this.stack = stack;
    }
    at(path) {
        const strPath = typeof path === 'string' ? path : path.join('/');
        return new StackPathInspector(this.stack, strPath);
    }
    toMatch(template, matchStyle = match_template_1.MatchStyle.EXACT) {
        return this.to(match_template_1.matchTemplate(template, matchStyle));
    }
    get value() {
        return this.stack.template;
    }
}
exports.StackInspector = StackInspector;
class StackPathInspector extends Inspector {
    constructor(stack, path) {
        super();
        this.stack = stack;
        this.path = path;
    }
    get value() {
        // The names of paths in metadata in tests are very ill-defined. Try with the full path first,
        // then try with the stack name preprended for backwards compat with most tests that happen to give
        // their stack an ID that's the same as the stack name.
        const metadata = this.stack.manifest.metadata || {};
        const md = metadata[this.path] || metadata[`/${this.stack.name}${this.path}`];
        if (md === undefined) {
            return undefined;
        }
        const resourceMd = md.find(entry => entry.type === api.LOGICAL_ID_METADATA_KEY);
        if (resourceMd === undefined) {
            return undefined;
        }
        const logicalId = resourceMd.data;
        return this.stack.template.Resources[logicalId];
    }
}
exports.StackPathInspector = StackPathInspector;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zcGVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW5zcGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsdUNBQXdDO0FBRXhDLDJDQUFrQztBQUNsQyxnRUFBd0U7QUFFeEUsTUFBc0IsU0FBUztJQUc3QjtRQUNFLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO0lBQ2hDLENBQUM7SUFFTSxFQUFFLENBQUMsU0FBMEI7UUFDbEMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDMUQsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVNLEtBQUssQ0FBQyxTQUEwQjtRQUNyQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUlPLEdBQUcsQ0FBQyxTQUEwQjtRQUNwQyxTQUFTLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hDLENBQUM7Q0FDRjtBQXJCRCw4QkFxQkM7QUFFRCxNQUFhLGNBQWUsU0FBUSxTQUFTO0lBQzNDLFlBQTRCLEtBQXNDO1FBQ2hFLEtBQUssRUFBRSxDQUFDO1FBRGtCLFVBQUssR0FBTCxLQUFLLENBQWlDO0lBRWxFLENBQUM7SUFFTSxFQUFFLENBQUMsSUFBdUI7UUFDL0IsTUFBTSxPQUFPLEdBQUcsT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakUsT0FBTyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVNLE9BQU8sQ0FBQyxRQUFnQyxFQUFFLFVBQVUsR0FBRywyQkFBVSxDQUFDLEtBQUs7UUFDNUUsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLDhCQUFhLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELElBQVcsS0FBSztRQUNkLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUM7SUFDN0IsQ0FBQztDQUNGO0FBakJELHdDQWlCQztBQUVELE1BQWEsa0JBQW1CLFNBQVEsU0FBUztJQUMvQyxZQUE0QixLQUFzQyxFQUFrQixJQUFZO1FBQzlGLEtBQUssRUFBRSxDQUFDO1FBRGtCLFVBQUssR0FBTCxLQUFLLENBQWlDO1FBQWtCLFNBQUksR0FBSixJQUFJLENBQVE7SUFFaEcsQ0FBQztJQUVELElBQVcsS0FBSztRQUNkLDhGQUE4RjtRQUM5RixtR0FBbUc7UUFDbkcsdURBQXVEO1FBQ3ZELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUM7UUFDcEQsTUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUM5RSxJQUFJLEVBQUUsS0FBSyxTQUFTLEVBQUU7WUFBRSxPQUFPLFNBQVMsQ0FBQztTQUFFO1FBQzNDLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ2hGLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUFFLE9BQU8sU0FBUyxDQUFDO1NBQUU7UUFDbkQsTUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQztRQUNsQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNsRCxDQUFDO0NBQ0Y7QUFqQkQsZ0RBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IHsgQXNzZXJ0aW9uIH0gZnJvbSAnLi9hc3NlcnRpb24nO1xuaW1wb3J0IHsgbm90IH0gZnJvbSAnLi9hc3NlcnRpb24nO1xuaW1wb3J0IHsgTWF0Y2hTdHlsZSwgbWF0Y2hUZW1wbGF0ZSB9IGZyb20gJy4vYXNzZXJ0aW9ucy9tYXRjaC10ZW1wbGF0ZSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbnNwZWN0b3Ige1xuICBwdWJsaWMgYXJvdW5kQXNzZXJ0PzogKGNiOiAoKSA9PiB2b2lkKSA9PiBhbnk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hcm91bmRBc3NlcnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgdG8oYXNzZXJ0aW9uOiBBc3NlcnRpb248dGhpcz4pOiBhbnkge1xuICAgIHJldHVybiB0aGlzLmFyb3VuZEFzc2VydCA/IHRoaXMuYXJvdW5kQXNzZXJ0KCgpID0+IHRoaXMuX3RvKGFzc2VydGlvbikpXG4gICAgICAgICAgICAgICAgIDogdGhpcy5fdG8oYXNzZXJ0aW9uKTtcbiAgfVxuXG4gIHB1YmxpYyBub3RUbyhhc3NlcnRpb246IEFzc2VydGlvbjx0aGlzPik6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMudG8obm90KGFzc2VydGlvbikpO1xuICB9XG5cbiAgYWJzdHJhY3QgZ2V0IHZhbHVlKCk6IGFueTtcblxuICBwcml2YXRlIF90byhhc3NlcnRpb246IEFzc2VydGlvbjx0aGlzPik6IGFueSB7XG4gICAgYXNzZXJ0aW9uLmFzc2VydE9yVGhyb3codGhpcyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0YWNrSW5zcGVjdG9yIGV4dGVuZHMgSW5zcGVjdG9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHN0YWNrOiBhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBhdChwYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSk6IFN0YWNrUGF0aEluc3BlY3RvciB7XG4gICAgY29uc3Qgc3RyUGF0aCA9IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyA/IHBhdGggOiBwYXRoLmpvaW4oJy8nKTtcbiAgICByZXR1cm4gbmV3IFN0YWNrUGF0aEluc3BlY3Rvcih0aGlzLnN0YWNrLCBzdHJQYXRoKTtcbiAgfVxuXG4gIHB1YmxpYyB0b01hdGNoKHRlbXBsYXRlOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LCBtYXRjaFN0eWxlID0gTWF0Y2hTdHlsZS5FWEFDVCkge1xuICAgIHJldHVybiB0aGlzLnRvKG1hdGNoVGVtcGxhdGUodGVtcGxhdGUsIG1hdGNoU3R5bGUpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmFsdWUoKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2sudGVtcGxhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0YWNrUGF0aEluc3BlY3RvciBleHRlbmRzIEluc3BlY3RvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzdGFjazogYXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCwgcHVibGljIHJlYWRvbmx5IHBhdGg6IHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCB1bmRlZmluZWQge1xuICAgIC8vIFRoZSBuYW1lcyBvZiBwYXRocyBpbiBtZXRhZGF0YSBpbiB0ZXN0cyBhcmUgdmVyeSBpbGwtZGVmaW5lZC4gVHJ5IHdpdGggdGhlIGZ1bGwgcGF0aCBmaXJzdCxcbiAgICAvLyB0aGVuIHRyeSB3aXRoIHRoZSBzdGFjayBuYW1lIHByZXByZW5kZWQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBtb3N0IHRlc3RzIHRoYXQgaGFwcGVuIHRvIGdpdmVcbiAgICAvLyB0aGVpciBzdGFjayBhbiBJRCB0aGF0J3MgdGhlIHNhbWUgYXMgdGhlIHN0YWNrIG5hbWUuXG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLnN0YWNrLm1hbmlmZXN0Lm1ldGFkYXRhIHx8IHt9O1xuICAgIGNvbnN0IG1kID0gbWV0YWRhdGFbdGhpcy5wYXRoXSB8fCBtZXRhZGF0YVtgLyR7dGhpcy5zdGFjay5uYW1lfSR7dGhpcy5wYXRofWBdO1xuICAgIGlmIChtZCA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICBjb25zdCByZXNvdXJjZU1kID0gbWQuZmluZChlbnRyeSA9PiBlbnRyeS50eXBlID09PSBhcGkuTE9HSUNBTF9JRF9NRVRBREFUQV9LRVkpO1xuICAgIGlmIChyZXNvdXJjZU1kID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIGNvbnN0IGxvZ2ljYWxJZCA9IHJlc291cmNlTWQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5zdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXNbbG9naWNhbElkXTtcbiAgfVxufVxuIl19