"use strict";
const nodeunit = require("nodeunit");
const stacks_1 = require("../lib/api/cxapp/stacks");
const sdk_1 = require("../lib/api/util/sdk");
const cdk_toolkit_1 = require("../lib/cdk-toolkit");
class MockStack {
    constructor(name, originalName = name, template = { Resources: { TempalteName: name } }, templateFile = `fake/stack/${name}.json`, assets = [], parameters = {}, environment = { name: 'MockEnv', account: '123456789012', region: 'bermuda-triangle-1' }) {
        this.name = name;
        this.originalName = originalName;
        this.template = template;
        this.templateFile = templateFile;
        this.assets = assets;
        this.parameters = parameters;
        this.environment = environment;
    }
}
class TestAppStacks extends stacks_1.AppStacks {
    constructor(test) {
        super(undefined);
        this.test = test;
    }
    getTagsFromStackMetadata(stack) {
        switch (stack.name) {
            case TestAppStacks.MOCK_STACK_A.name:
                return [{ Key: 'Foo', Value: 'Bar' }];
            case TestAppStacks.MOCK_STACK_B.name:
                return [{ Key: 'Baz', Value: 'Zinga!' }];
            default:
                throw new Error(`Not an expected mock stack: ${stack.name}`);
        }
    }
    selectStacks(selectors) {
        this.test.deepEqual(selectors, ['Test-Stack-A', 'Test-Stack-B']);
        return Promise.resolve([
            // Cheating the type system here (intentionally, so we have to stub less!)
            TestAppStacks.MOCK_STACK_A,
            TestAppStacks.MOCK_STACK_B,
        ]);
    }
    processMetadata(stacks) {
        stacks.forEach(stack => this.test.ok(stack === TestAppStacks.MOCK_STACK_A || stack === TestAppStacks.MOCK_STACK_B, `Not an expected mock stack: ${stack.name}`));
    }
    listStacks() {
        throw new Error('Not Implemented');
    }
    synthesizeStack() {
        throw new Error('Not Implemented');
    }
    synthesizeStacks() {
        throw new Error('Not Implemented');
    }
}
TestAppStacks.MOCK_STACK_A = new MockStack('Test-Stack-A');
TestAppStacks.MOCK_STACK_B = new MockStack('Test-Stack-B');
class TestProvisioner {
    constructor(test, expectedTags = {}) {
        this.test = test;
        this.expectedTags = {};
        for (const [stackName, tags] of Object.entries(expectedTags)) {
            this.expectedTags[stackName] =
                Object.entries(tags).map(([Key, Value]) => ({ Key, Value }))
                    .sort((l, r) => l.Key.localeCompare(r.Key));
        }
    }
    deployStack(options) {
        this.test.ok(options.stack.name === TestAppStacks.MOCK_STACK_A.name || options.stack.name === TestAppStacks.MOCK_STACK_B.name, `Not an expected mock stack: ${options.stack.name}`);
        this.test.deepEqual(options.tags, this.expectedTags[options.stack.name]);
        return Promise.resolve({
            stackArn: `arn:aws:cloudformation:::stack/${options.stack.name}/MockedOut`,
            noOp: false,
            outputs: { StackName: options.stack.name },
        });
    }
    readCurrentTemplate(stack) {
        switch (stack.name) {
            case TestAppStacks.MOCK_STACK_A.name:
                return Promise.resolve({});
            case TestAppStacks.MOCK_STACK_B.name:
                return Promise.resolve({});
            default:
                return Promise.reject(`Not an expected mock stack: ${stack.name}`);
        }
    }
}
module.exports = nodeunit.testCase({
    deploy: {
        'makes correct CloudFormation calls': {
            'without options'(test) {
                // GIVEN
                const toolkit = new cdk_toolkit_1.CdkToolkit({
                    appStacks: new TestAppStacks(test),
                    provisioner: new TestProvisioner(test, {
                        'Test-Stack-A': { Foo: 'Bar' },
                        'Test-Stack-B': { Baz: 'Zinga!' },
                    }),
                });
                // WHEN
                toolkit.deploy({ stackNames: ['Test-Stack-A', 'Test-Stack-B'], sdk: new sdk_1.SDK() });
                // THEN
                test.done();
            },
        },
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5jZGstdG9vbGtpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlc3QuY2RrLXRvb2xraXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLHFDQUFzQztBQUN0QyxvREFBeUQ7QUFHekQsNkNBQTBDO0FBQzFDLG9EQUFnRDtBQXlCaEQsTUFBTSxTQUFTO0lBQ2IsWUFDa0IsSUFBWSxFQUNaLGVBQXVCLElBQUksRUFDM0IsV0FBZ0IsRUFBRSxTQUFTLEVBQUUsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFDckQsZUFBdUIsY0FBYyxJQUFJLE9BQU8sRUFDaEQsU0FBcUMsRUFBRSxFQUN2QyxhQUF1QyxFQUFFLEVBQ3pDLGNBQWlDLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxvQkFBb0IsRUFBRTtRQU4zRyxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQ1osaUJBQVksR0FBWixZQUFZLENBQWU7UUFDM0IsYUFBUSxHQUFSLFFBQVEsQ0FBNkM7UUFDckQsaUJBQVksR0FBWixZQUFZLENBQW9DO1FBQ2hELFdBQU0sR0FBTixNQUFNLENBQWlDO1FBQ3ZDLGVBQVUsR0FBVixVQUFVLENBQStCO1FBQ3pDLGdCQUFXLEdBQVgsV0FBVyxDQUFnRztJQUMxSCxDQUFDO0NBQ0w7QUFFRCxNQUFNLGFBQWMsU0FBUSxrQkFBUztJQUluQyxZQUE2QixJQUFtQjtRQUM5QyxLQUFLLENBQUMsU0FBZ0IsQ0FBQyxDQUFDO1FBREcsU0FBSSxHQUFKLElBQUksQ0FBZTtJQUVoRCxDQUFDO0lBRU0sd0JBQXdCLENBQUMsS0FBd0M7UUFDdEUsUUFBUSxLQUFLLENBQUMsSUFBSSxFQUFFO1lBQ2xCLEtBQUssYUFBYSxDQUFDLFlBQVksQ0FBQyxJQUFJO2dCQUNsQyxPQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLEtB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T0FBTztnQkFDUCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDZCxDQUFDO1NBQ0Y7S0FDRjtDQUNGLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IG5vZGV1bml0ID0gcmVxdWlyZSgnbm9kZXVuaXQnKTtcbmltcG9ydCB7IEFwcFN0YWNrcywgVGFnIH0gZnJvbSAnLi4vbGliL2FwaS9jeGFwcC9zdGFja3MnO1xuaW1wb3J0IHsgRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuLi9saWIvYXBpL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBEZXBsb3lTdGFja09wdGlvbnMsIElEZXBsb3ltZW50VGFyZ2V0LCBUZW1wbGF0ZSB9IGZyb20gJy4uL2xpYi9hcGkvZGVwbG95bWVudC10YXJnZXQnO1xuaW1wb3J0IHsgU0RLIH0gZnJvbSAnLi4vbGliL2FwaS91dGlsL3Nkayc7XG5pbXBvcnQgeyBDZGtUb29sa2l0IH0gZnJvbSAnLi4vbGliL2Nkay10b29sa2l0JztcblxuZXhwb3J0ID0gbm9kZXVuaXQudGVzdENhc2Uoe1xuICBkZXBsb3k6IHtcbiAgICAnbWFrZXMgY29ycmVjdCBDbG91ZEZvcm1hdGlvbiBjYWxscyc6IHtcbiAgICAgICd3aXRob3V0IG9wdGlvbnMnKHRlc3Q6IG5vZGV1bml0LlRlc3QpIHtcbiAgICAgICAgLy8gR0lWRU5cbiAgICAgICAgY29uc3QgdG9vbGtpdCA9IG5ldyBDZGtUb29sa2l0KHtcbiAgICAgICAgICBhcHBTdGFja3M6IG5ldyBUZXN0QXBwU3RhY2tzKHRlc3QpLFxuICAgICAgICAgIHByb3Zpc2lvbmVyOiBuZXcgVGVzdFByb3Zpc2lvbmVyKHRlc3QsIHtcbiAgICAgICAgICAgICdUZXN0LVN0YWNrLUEnOiB7IEZvbzogJ0JhcicgfSxcbiAgICAgICAgICAgICdUZXN0LVN0YWNrLUInOiB7IEJhejogJ1ppbmdhIScgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV0hFTlxuICAgICAgICB0b29sa2l0LmRlcGxveSh7IHN0YWNrTmFtZXM6IFsnVGVzdC1TdGFjay1BJywgJ1Rlc3QtU3RhY2stQiddLCBzZGs6IG5ldyBTREsoKSB9KTtcblxuICAgICAgICAvLyBUSEVOXG4gICAgICAgIHRlc3QuZG9uZSgpO1xuICAgICAgfSxcbiAgICB9LFxuICB9LFxufSk7XG5cbmNsYXNzIE1vY2tTdGFjayB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IG9yaWdpbmFsTmFtZTogc3RyaW5nID0gbmFtZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgdGVtcGxhdGU6IGFueSA9IHsgUmVzb3VyY2VzOiB7IFRlbXBhbHRlTmFtZTogbmFtZSB9IH0sXG4gICAgcHVibGljIHJlYWRvbmx5IHRlbXBsYXRlRmlsZTogc3RyaW5nID0gYGZha2Uvc3RhY2svJHtuYW1lfS5qc29uYCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXNzZXRzOiBjeGFwaS5Bc3NldE1ldGFkYXRhRW50cnlbXSA9IFtdLFxuICAgIHB1YmxpYyByZWFkb25seSBwYXJhbWV0ZXJzOiB7IFtpZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50ID0geyBuYW1lOiAnTW9ja0VudicsIGFjY291bnQ6ICcxMjM0NTY3ODkwMTInLCByZWdpb246ICdiZXJtdWRhLXRyaWFuZ2xlLTEnIH0sXG4gICkge31cbn1cblxuY2xhc3MgVGVzdEFwcFN0YWNrcyBleHRlbmRzIEFwcFN0YWNrcyB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTU9DS19TVEFDS19BID0gbmV3IE1vY2tTdGFjaygnVGVzdC1TdGFjay1BJyk7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTU9DS19TVEFDS19CID0gbmV3IE1vY2tTdGFjaygnVGVzdC1TdGFjay1CJyk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB0ZXN0OiBub2RldW5pdC5UZXN0KSB7XG4gICAgc3VwZXIodW5kZWZpbmVkIGFzIGFueSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0VGFnc0Zyb21TdGFja01ldGFkYXRhKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpOiBUYWdbXSB7XG4gICAgc3dpdGNoIChzdGFjay5uYW1lKSB7XG4gICAgICBjYXNlIFRlc3RBcHBTdGFja3MuTU9DS19TVEFDS19BLm5hbWU6XG4gICAgICAgIHJldHVybiBbeyBLZXk6ICdGb28nLCBWYWx1ZTogJ0JhcicgfV07XG4gICAgICBjYXNlIFRlc3RBcHBTdGFja3MuTU9DS19TVEFDS19CLm5hbWU6XG4gICAgICAgIHJldHVybiBbeyBLZXk6ICdCYXonLCBWYWx1ZTogJ1ppbmdhIScgfV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbiBleHBlY3RlZCBtb2NrIHN0YWNrOiAke3N0YWNrLm5hbWV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNlbGVjdFN0YWNrcyhzZWxlY3RvcnM6IHN0cmluZ1tdKTogUHJvbWlzZTxjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXT4ge1xuICAgIHRoaXMudGVzdC5kZWVwRXF1YWwoc2VsZWN0b3JzLCBbJ1Rlc3QtU3RhY2stQScsICdUZXN0LVN0YWNrLUInXSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXG4gICAgICAvLyBDaGVhdGluZyB0aGUgdHlwZSBzeXN0ZW0gaGVyZSAoaW50ZW50aW9uYWxseSwgc28gd2UgaGF2ZSB0byBzdHViIGxlc3MhKVxuICAgICAgVGVzdEFwcFN0YWNrcy5NT0NLX1NUQUNLX0EgYXMgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICAgICAgVGVzdEFwcFN0YWNrcy5NT0NLX1NUQUNLX0IgYXMgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICAgIF0pO1xuICB9XG5cbiAgcHVibGljIHByb2Nlc3NNZXRhZGF0YShzdGFja3M6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdKTogdm9pZCB7XG4gICAgc3RhY2tzLmZvckVhY2goc3RhY2sgPT5cbiAgICAgIHRoaXMudGVzdC5vayhzdGFjayA9PT0gVGVzdEFwcFN0YWNrcy5NT0NLX1NUQUNLX0EgfHwgc3RhY2sgPT09IFRlc3RBcHBTdGFja3MuTU9DS19TVEFDS19CLFxuICAgICAgICBgTm90IGFuIGV4cGVjdGVkIG1vY2sgc3RhY2s6ICR7c3RhY2submFtZX1gKSk7XG4gIH1cblxuICBwdWJsaWMgbGlzdFN0YWNrcygpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIHB1YmxpYyBzeW50aGVzaXplU3RhY2soKTogbmV2ZXIge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XG4gIH1cblxuICBwdWJsaWMgc3ludGhlc2l6ZVN0YWNrcygpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5jbGFzcyBUZXN0UHJvdmlzaW9uZXIgaW1wbGVtZW50cyBJRGVwbG95bWVudFRhcmdldCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXhwZWN0ZWRUYWdzOiB7IFtzeXRhY2tOYW1lOiBzdHJpbmddOiBUYWdbXSB9ID0ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZXN0OiBub2RldW5pdC5UZXN0LFxuICAgIGV4cGVjdGVkVGFnczogeyBbc3l0YWNrTmFtZTogc3RyaW5nXTogeyBba2F5OiBzdHJpbmddOiBzdHJpbmcgfSB9ID0ge30sXG4gICkge1xuICAgIGZvciAoY29uc3QgW3N0YWNrTmFtZSwgdGFnc10gb2YgT2JqZWN0LmVudHJpZXMoZXhwZWN0ZWRUYWdzKSkge1xuICAgICAgdGhpcy5leHBlY3RlZFRhZ3Nbc3RhY2tOYW1lXSA9XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRhZ3MpLm1hcCgoW0tleSwgVmFsdWVdKSA9PiAoeyBLZXksIFZhbHVlIH0pKVxuICAgICAgICAgIC5zb3J0KChsLCByKSA9PiAgbC5LZXkubG9jYWxlQ29tcGFyZShyLktleSkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXBsb3lTdGFjayhvcHRpb25zOiBEZXBsb3lTdGFja09wdGlvbnMpOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgdGhpcy50ZXN0Lm9rKFxuICAgICAgb3B0aW9ucy5zdGFjay5uYW1lID09PSBUZXN0QXBwU3RhY2tzLk1PQ0tfU1RBQ0tfQS5uYW1lIHx8IG9wdGlvbnMuc3RhY2submFtZSA9PT0gVGVzdEFwcFN0YWNrcy5NT0NLX1NUQUNLX0IubmFtZSxcbiAgICAgIGBOb3QgYW4gZXhwZWN0ZWQgbW9jayBzdGFjazogJHtvcHRpb25zLnN0YWNrLm5hbWV9YFxuICAgICk7XG4gICAgdGhpcy50ZXN0LmRlZXBFcXVhbChvcHRpb25zLnRhZ3MsIHRoaXMuZXhwZWN0ZWRUYWdzW29wdGlvbnMuc3RhY2submFtZV0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgc3RhY2tBcm46IGBhcm46YXdzOmNsb3VkZm9ybWF0aW9uOjo6c3RhY2svJHtvcHRpb25zLnN0YWNrLm5hbWV9L01vY2tlZE91dGAsXG4gICAgICBub09wOiBmYWxzZSxcbiAgICAgIG91dHB1dHM6IHsgU3RhY2tOYW1lOiBvcHRpb25zLnN0YWNrLm5hbWUgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkQ3VycmVudFRlbXBsYXRlKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gICAgc3dpdGNoIChzdGFjay5uYW1lKSB7XG4gICAgICBjYXNlIFRlc3RBcHBTdGFja3MuTU9DS19TVEFDS19BLm5hbWU6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgICAgY2FzZSBUZXN0QXBwU3RhY2tzLk1PQ0tfU1RBQ0tfQi5uYW1lOlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgTm90IGFuIGV4cGVjdGVkIG1vY2sgc3RhY2s6ICR7c3RhY2submFtZX1gKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==