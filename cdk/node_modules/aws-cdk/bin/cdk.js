#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const colors = require("colors/safe");
const path = require("path");
const yargs = require("yargs");
const lib_1 = require("../lib");
const environments_1 = require("../lib/api/cxapp/environments");
const exec_1 = require("../lib/api/cxapp/exec");
const stacks_1 = require("../lib/api/cxapp/stacks");
const deployment_target_1 = require("../lib/api/deployment-target");
const cdk_toolkit_1 = require("../lib/cdk-toolkit");
const diff_1 = require("../lib/diff");
const init_1 = require("../lib/init");
const logging_1 = require("../lib/logging");
const plugin_1 = require("../lib/plugin");
const serialize_1 = require("../lib/serialize");
const settings_1 = require("../lib/settings");
const version = require("../lib/version");
// tslint:disable:no-shadowed-variable max-line-length
async function parseCommandLineArguments() {
    const initTemplateLanuages = await init_1.availableInitLanguages;
    return yargs
        .env('CDK')
        .usage('Usage: cdk -a <cdk-app> COMMAND')
        .option('app', { type: 'string', alias: 'a', desc: 'REQUIRED: command-line for executing your app or a cloud assembly directory (e.g. "node bin/my-app.js")', requiresArg: true })
        .option('context', { type: 'array', alias: 'c', desc: 'Add contextual string parameter (KEY=VALUE)', nargs: 1, requiresArg: true })
        .option('plugin', { type: 'array', alias: 'p', desc: 'Name or path of a node package that extend the CDK features. Can be specified multiple times', nargs: 1 })
        .option('trace', { type: 'boolean', desc: 'Print trace for stack warnings' })
        .option('strict', { type: 'boolean', desc: 'Do not construct stacks with warnings' })
        .option('ignore-errors', { type: 'boolean', default: false, desc: 'Ignores synthesis errors, which will likely produce an invalid output' })
        .option('json', { type: 'boolean', alias: 'j', desc: 'Use JSON output instead of YAML when templates are printed to STDOUT', default: false })
        .option('verbose', { type: 'boolean', alias: 'v', desc: 'Show debug logs', default: false })
        .option('profile', { type: 'string', desc: 'Use the indicated AWS profile as the default environment', requiresArg: true })
        .option('proxy', { type: 'string', desc: 'Use the indicated proxy. Will read from HTTPS_PROXY environment variable if not specified.', requiresArg: true })
        .option('ec2creds', { type: 'boolean', alias: 'i', default: undefined, desc: 'Force trying to fetch EC2 instance credentials. Default: guess EC2 instance status.' })
        .option('version-reporting', { type: 'boolean', desc: 'Include the "AWS::CDK::Metadata" resource in synthesized templates (enabled by default)', default: undefined })
        .option('path-metadata', { type: 'boolean', desc: 'Include "aws:cdk:path" CloudFormation metadata for each resource (enabled by default)', default: true })
        .option('asset-metadata', { type: 'boolean', desc: 'Include "aws:asset:*" CloudFormation metadata for resources that user assets (enabled by default)', default: true })
        .option('role-arn', { type: 'string', alias: 'r', desc: 'ARN of Role to use when invoking CloudFormation', default: undefined, requiresArg: true })
        .option('toolkit-stack-name', { type: 'string', desc: 'The name of the CDK toolkit stack', requiresArg: true })
        .option('staging', { type: 'boolean', desc: 'Copy assets to the output directory (use --no-staging to disable, needed for local debugging the source files with SAM CLI)', default: true })
        .option('output', { type: 'string', alias: 'o', desc: 'Emits the synthesized cloud assembly into a directory (default: cdk.out)', requiresArg: true })
        .option('no-color', { type: 'boolean', desc: 'Removes colors and other style from console output', default: false })
        .command(['list [STACKS..]', 'ls [STACKS..]'], 'Lists all stacks in the app', yargs => yargs
        .option('long', { type: 'boolean', default: false, alias: 'l', desc: 'Display environment information for each stack' }))
        .command(['synthesize [STACKS..]', 'synth [STACKS..]'], 'Synthesizes and prints the CloudFormation template for this stack', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependencies' }))
        .command('bootstrap [ENVIRONMENTS..]', 'Deploys the CDK toolkit stack into an AWS environment', yargs => yargs
        .option('bootstrap-bucket-name', { type: 'string', alias: ['b', 'toolkit-bucket-name'], desc: 'The name of the CDK toolkit bucket', default: undefined })
        .option('bootstrap-kms-key-id', { type: 'string', desc: 'AWS KMS master key ID used for the SSE-KMS encryption', default: undefined }))
        .command('deploy [STACKS..]', 'Deploys the stack(s) named STACKS into your AWS account', yargs => yargs
        .option('build-exclude', { type: 'array', alias: 'E', nargs: 1, desc: 'Do not rebuild asset with the given ID. Can be specified multiple times.', default: [] })
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependencies' })
        .option('require-approval', { type: 'string', choices: [diff_1.RequireApproval.Never, diff_1.RequireApproval.AnyChange, diff_1.RequireApproval.Broadening], desc: 'What security-sensitive changes need manual approval' })
        .option('ci', { type: 'boolean', desc: 'Force CI detection. Use --no-ci to disable CI autodetection.', default: process.env.CI !== undefined })
        .option('tags', { type: 'array', alias: 't', desc: 'Tags to add to the stack (KEY=VALUE)', nargs: 1, requiresArg: true }))
        .command('destroy [STACKS..]', 'Destroy the stack(s) named STACKS', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only deploy requested stacks, don\'t include dependees' })
        .option('force', { type: 'boolean', alias: 'f', desc: 'Do not ask for confirmation before destroying the stacks' }))
        .command('diff [STACKS..]', 'Compares the specified stack with the deployed stack or a local template file, and returns with status 1 if any difference is found', yargs => yargs
        .option('exclusively', { type: 'boolean', alias: 'e', desc: 'Only diff requested stacks, don\'t include dependencies' })
        .option('context-lines', { type: 'number', desc: 'Number of context lines to include in arbitrary JSON diff rendering', default: 3, requiresArg: true })
        .option('template', { type: 'string', desc: 'The path to the CloudFormation template to compare with', requiresArg: true })
        .option('strict', { type: 'boolean', desc: 'Do not filter out AWS::CDK::Metadata resources', default: false }))
        .command('metadata [STACK]', 'Returns all metadata associated with this stack')
        .command('init [TEMPLATE]', 'Create a new, empty CDK project from a template. Invoked without TEMPLATE, the app template will be used.', yargs => yargs
        .option('language', { type: 'string', alias: 'l', desc: 'The language to be used for the new project (default can be configured in ~/.cdk.json)', choices: initTemplateLanuages })
        .option('list', { type: 'boolean', desc: 'List the available templates' }))
        .commandDir('../lib/commands', { exclude: /^_.*/ })
        .version(version.DISPLAY_VERSION)
        .demandCommand(1, '') // just print help
        .help()
        .alias('h', 'help')
        .epilogue([
        'If your app has a single stack, there is no need to specify the stack name',
        'If one of cdk.json or ~/.cdk.json exists, options specified there will be used as defaults. Settings in cdk.json take precedence.'
    ].join('\n\n'))
        .argv;
}
if (!process.stdout.isTTY) {
    colors.disable();
}
async function initCommandLine() {
    const argv = await parseCommandLineArguments();
    if (argv.verbose) {
        logging_1.setVerbose();
    }
    logging_1.debug('CDK toolkit version:', version.DISPLAY_VERSION);
    logging_1.debug('Command line arguments:', argv);
    const aws = new lib_1.SDK({
        profile: argv.profile,
        proxyAddress: argv.proxy,
        ec2creds: argv.ec2creds,
    });
    const configuration = new settings_1.Configuration(argv);
    await configuration.load();
    const provisioner = new deployment_target_1.CloudFormationDeploymentTarget({ aws });
    const appStacks = new stacks_1.AppStacks({
        verbose: argv.trace || argv.verbose,
        ignoreErrors: argv['ignore-errors'],
        strict: argv.strict,
        configuration,
        aws,
        synthesizer: exec_1.execProgram,
    });
    /** Function to load plug-ins, using configurations additively. */
    function loadPlugins(...settings) {
        const loaded = new Set();
        for (const source of settings) {
            const plugins = source.get(['plugin']) || [];
            for (const plugin of plugins) {
                const resolved = tryResolve(plugin);
                if (loaded.has(resolved)) {
                    continue;
                }
                logging_1.debug(`Loading plug-in: ${colors.green(plugin)} from ${colors.blue(resolved)}`);
                plugin_1.PluginHost.instance.load(plugin);
                loaded.add(resolved);
            }
        }
        function tryResolve(plugin) {
            try {
                return require.resolve(plugin);
            }
            catch (e) {
                logging_1.error(`Unable to resolve plugin ${colors.green(plugin)}: ${e.stack}`);
                throw new Error(`Unable to resolve plug-in: ${plugin}`);
            }
        }
    }
    loadPlugins(configuration.settings);
    const cmd = argv._[0];
    // Bundle up global objects so the commands have access to them
    const commandOptions = { args: argv, appStacks, configuration, aws };
    try {
        const returnValue = argv.commandHandler
            ? await argv.commandHandler(commandOptions)
            : await main(cmd, argv);
        if (typeof returnValue === 'object') {
            return toJsonOrYaml(returnValue);
        }
        else if (typeof returnValue === 'string') {
            return returnValue;
        }
        else {
            return returnValue;
        }
    }
    finally {
        await version.displayVersionMessage();
    }
    async function main(command, args) {
        const toolkitStackName = configuration.settings.get(['toolkitStackName']) || deployment_target_1.DEFAULT_TOOLKIT_STACK_NAME;
        if (toolkitStackName !== deployment_target_1.DEFAULT_TOOLKIT_STACK_NAME) {
            logging_1.print(`Toolkit stack: ${colors.bold(toolkitStackName)}`);
        }
        args.STACKS = args.STACKS || [];
        args.ENVIRONMENTS = args.ENVIRONMENTS || [];
        const cli = new cdk_toolkit_1.CdkToolkit({ appStacks, provisioner });
        switch (command) {
            case 'ls':
            case 'list':
                return await cliList(args.STACKS, { long: args.long });
            case 'diff':
                return await cli.diff({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    templatePath: args.template,
                    strict: args.strict,
                    contextLines: args.contextLines
                });
            case 'bootstrap':
                return await cliBootstrap(args.ENVIRONMENTS, toolkitStackName, args.roleArn, {
                    bucketName: configuration.settings.get(['toolkitBucket', 'bucketName']),
                    kmsKeyId: configuration.settings.get(['toolkitBucket', 'kmsKeyId']),
                });
            case 'deploy':
                return await cli.deploy({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    toolkitStackName,
                    roleArn: args.roleArn,
                    requireApproval: configuration.settings.get(['requireApproval']),
                    ci: args.ci,
                    reuseAssets: args['build-exclude'],
                    tags: configuration.settings.get(['tags']),
                    sdk: aws,
                });
            case 'destroy':
                return await cli.destroy({
                    stackNames: args.STACKS,
                    exclusively: args.exclusively,
                    force: args.force,
                    roleArn: args.roleArn,
                    sdk: aws,
                });
            case 'synthesize':
            case 'synth':
                return await cliSynthesize(args.STACKS, args.exclusively);
            case 'metadata':
                return await cliMetadata(await findStack(args.STACK));
            case 'init':
                const language = configuration.settings.get(['language']);
                if (args.list) {
                    return await init_1.printAvailableTemplates(language);
                }
                else {
                    return await init_1.cliInit(args.TEMPLATE, language);
                }
            default:
                throw new Error('Unknown command: ' + command);
        }
    }
    async function cliMetadata(stackName) {
        const s = await appStacks.synthesizeStack(stackName);
        return s.manifest.metadata || {};
    }
    /**
     * Bootstrap the CDK Toolkit stack in the accounts used by the specified stack(s).
     *
     * @param environmentGlobs environment names that need to have toolkit support
     *             provisioned, as a glob filter. If none is provided,
     *             all stacks are implicitly selected.
     * @param toolkitStackName the name to be used for the CDK Toolkit stack.
     */
    async function cliBootstrap(environmentGlobs, toolkitStackName, roleArn, props) {
        // Two modes of operation.
        //
        // If there is an '--app' argument, we select the environments from the app. Otherwise we just take the user
        // at their word that they know the name of the environment.
        const app = configuration.settings.get(['app']);
        const environments = app ? await environments_1.globEnvironmentsFromStacks(appStacks, environmentGlobs, aws) : environments_1.environmentsFromDescriptors(environmentGlobs);
        await Promise.all(environments.map(async (environment) => {
            logging_1.success(' ⏳  Bootstrapping environment %s...', colors.blue(environment.name));
            try {
                const result = await lib_1.bootstrapEnvironment(environment, aws, toolkitStackName, roleArn, props);
                const message = result.noOp ? ' ✅  Environment %s bootstrapped (no changes).'
                    : ' ✅  Environment %s bootstrapped.';
                logging_1.success(message, colors.blue(environment.name));
            }
            catch (e) {
                logging_1.error(' ❌  Environment %s failed bootstrapping: %s', colors.blue(environment.name), e);
                throw e;
            }
        }));
    }
    /**
     * Synthesize the given set of stacks (called when the user runs 'cdk synth')
     *
     * INPUT: Stack names can be supplied using a glob filter. If no stacks are
     * given, all stacks from the application are implictly selected.
     *
     * OUTPUT: If more than one stack ends up being selected, an output directory
     * should be supplied, where the templates will be written.
     */
    async function cliSynthesize(stackNames, exclusively) {
        // Only autoselect dependencies if it doesn't interfere with user request or output options
        const autoSelectDependencies = !exclusively;
        const stacks = await appStacks.selectStacks(stackNames, {
            extend: autoSelectDependencies ? stacks_1.ExtendedStackSelection.Upstream : stacks_1.ExtendedStackSelection.None,
            defaultBehavior: stacks_1.DefaultSelection.AllStacks
        });
        appStacks.processMetadata(stacks);
        // if we have a single stack, print it to STDOUT
        if (stacks.length === 1) {
            return stacks[0].template;
        }
        // This is a slight hack; in integ mode we allow multiple stacks to be synthesized to stdout sequentially.
        // This is to make it so that we can support multi-stack integ test expectations, without so drastically
        // having to change the synthesis format that we have to rerun all integ tests.
        //
        // Because this feature is not useful to consumers (the output is missing
        // the stack names), it's not exposed as a CLI flag. Instead, it's hidden
        // behind an environment variable.
        const isIntegMode = process.env.CDK_INTEG_MODE === '1';
        if (isIntegMode) {
            return stacks.map(s => s.template);
        }
        // not outputting template to stdout, let's explain things to the user a little bit...
        logging_1.success(`Successfully synthesized to ${colors.blue(path.resolve(appStacks.assembly.directory))}`);
        logging_1.print(`Supply a stack name (${stacks.map(s => colors.green(s.name)).join(', ')}) to display its template.`);
        return undefined;
    }
    async function cliList(selectors, options = {}) {
        const stacks = await appStacks.selectStacks(selectors, { defaultBehavior: stacks_1.DefaultSelection.AllStacks });
        // if we are in "long" mode, emit the array as-is (JSON/YAML)
        if (options.long) {
            const long = [];
            for (const stack of stacks) {
                long.push({
                    name: stack.name,
                    environment: stack.environment
                });
            }
            return long; // will be YAML formatted output
        }
        // just print stack names
        for (const stack of stacks) {
            logging_1.data(stack.name);
        }
        return 0; // exit-code
    }
    /**
     * Match a single stack from the list of available stacks
     */
    async function findStack(name) {
        const stacks = await appStacks.selectStacks([name], {
            extend: stacks_1.ExtendedStackSelection.None,
            defaultBehavior: stacks_1.DefaultSelection.None
        });
        // Could have been a glob so check that we evaluated to exactly one
        if (stacks.length > 1) {
            throw new Error(`This command requires exactly one stack and we matched more than one: ${stacks.map(x => x.name)}`);
        }
        return stacks[0].name;
    }
    function toJsonOrYaml(object) {
        return serialize_1.serializeStructure(object, argv.json);
    }
}
initCommandLine()
    .then(value => {
    if (value == null) {
        return;
    }
    if (typeof value === 'string') {
        logging_1.data(value);
    }
    else if (typeof value === 'number') {
        process.exit(value);
    }
})
    .catch(err => {
    logging_1.error(err.message);
    logging_1.debug(err.stack);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHVDQUFxQztBQUVyQyxzQ0FBdUM7QUFDdkMsNkJBQThCO0FBQzlCLCtCQUFnQztBQUVoQyxnQ0FBOEU7QUFDOUUsZ0VBQXdHO0FBQ3hHLGdEQUFvRDtBQUNwRCxvREFBOEY7QUFDOUYsb0VBQTBHO0FBQzFHLG9EQUFnRDtBQUNoRCxzQ0FBOEM7QUFDOUMsc0NBQXVGO0FBQ3ZGLDRDQUFnRjtBQUNoRiwwQ0FBMkM7QUFDM0MsZ0RBQXNEO0FBQ3RELDhDQUEwRDtBQUMxRCwwQ0FBMkM7QUFFM0Msc0RBQXNEO0FBQ3RELEtBQUssVUFBVSx5QkFBeUI7SUFDdEMsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLDZCQUFzQixDQUFDO0lBQzFELE9BQU8sS0FBSztTQUNULEdBQUcsQ0FBQyxLQUFLLENBQUM7U0FDVixLQUFLLENBQUMsaUNBQWlDLENBQUM7U0FDeEMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUseUdBQXlHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2pMLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDZDQUE2QyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2xJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLDhGQUE4RixFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUMvSixNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsZ0NBQWdDLEVB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LENBQUMseUVBQXlFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3JIO1FBRUQsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxTQUFTLFlBQVksQ0FBQyxNQUFXO1FBQy9CLE9BQU8sOEJBQWtCLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQyxDQUFDO0FBQ0gsQ0FBQztBQUVELGVBQWUsRUFBRTtLQUNkLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUNaLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtRQUFFLE9BQU87S0FBRTtJQUM5QixJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM3QixjQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDYjtTQUFNLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQ3BDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDckI7QUFDSCxDQUFDLENBQUM7S0FDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDWCxlQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CLGVBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IG5vZGVcbmltcG9ydCAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcblxuaW1wb3J0IGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycy9zYWZlJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCB5YXJncyA9IHJlcXVpcmUoJ3lhcmdzJyk7XG5cbmltcG9ydCB7IGJvb3RzdHJhcEVudmlyb25tZW50LCBCb290c3RyYXBFbnZpcm9ubWVudFByb3BzLCBTREsgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgZW52aXJvbm1lbnRzRnJvbURlc2NyaXB0b3JzLCBnbG9iRW52aXJvbm1lbnRzRnJvbVN0YWNrcyB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvZW52aXJvbm1lbnRzJztcbmltcG9ydCB7IGV4ZWNQcm9ncmFtIH0gZnJvbSAnLi4vbGliL2FwaS9jeGFwcC9leGVjJztcbmltcG9ydCB7IEFwcFN0YWNrcywgRGVmYXVsdFNlbGVjdGlvbiwgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbiB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvc3RhY2tzJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uRGVwbG95bWVudFRhcmdldCwgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgfSBmcm9tICcuLi9saWIvYXBpL2RlcGxveW1lbnQtdGFyZ2V0JztcbmltcG9ydCB7IENka1Rvb2xraXQgfSBmcm9tICcuLi9saWIvY2RrLXRvb2xraXQnO1xuaW1wb3J0IHsgUmVxdWlyZUFwcHJvdmFsIH0gZnJvbSAnLi4vbGliL2RpZmYnO1xuaW1wb3J0IHsgYXZhaWxhYmxlSW5pdExhbmd1YWdlcywgY2xpSW5pdCwgcHJpbnRBdmFpbGFibGVUZW1wbGF0ZXMgfSBmcm9tICcuLi9saWIvaW5pdCc7XG5pbXBvcnQgeyBkYXRhLCBkZWJ1ZywgZXJyb3IsIHByaW50LCBzZXRWZXJib3NlLCBzdWNjZXNzIH0gZnJvbSAnLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHsgUGx1Z2luSG9zdCB9IGZyb20gJy4uL2xpYi9wbHVnaW4nO1xuaW1wb3J0IHsgc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vbGliL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uLCBTZXR0aW5ncyB9IGZyb20gJy4uL2xpYi9zZXR0aW5ncyc7XG5pbXBvcnQgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL2xpYi92ZXJzaW9uJyk7XG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLXNoYWRvd2VkLXZhcmlhYmxlIG1heC1saW5lLWxlbmd0aFxuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21tYW5kTGluZUFyZ3VtZW50cygpIHtcbiAgY29uc3QgaW5pdFRlbXBsYXRlTGFudWFnZXMgPSBhd2FpdCBhdmFpbGFibGVJbml0TGFuZ3VhZ2VzO1xuICByZXR1cm4geWFyZ3NcbiAgICAuZW52KCdDREsnKVxuICAgIC51c2FnZSgnVXNhZ2U6IGNkayAtYSA8Y2RrLWFwcD4gQ09NTUFORCcpXG4gICAgLm9wdGlvbignYXBwJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdhJywgZGVzYzogJ1JFUVVJUkVEOiBjb21tYW5kLWxpbmUgZm9yIGV4ZWN1dGluZyB5b3VyIGFwcCBvciBhIGNsb3VkIGFzc2VtYmx5IGRpcmVjdG9yeSAoZS5nLiBcIm5vZGUgYmluL215LWFwcC5qc1wiKScsIHJlcXVpcmVzQXJnOiB0cnVlIH0pXG4gICAgLm9wdGlvbignY29udGV4dCcsIHsgdHlwZTogJ2FycmF5JywgYWxpYXM6ICdjJywgZGVzYzogJ0FkZCBjb250ZXh0dWFsIHN0cmluZyBwYXJhbWV0ZXIgKEtFWT1WQUxVRSknLCBuYXJnczogMSwgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdwbHVnaW4nLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAncCcsIGRlc2M6ICdOYW1lIG9yIHBhdGggb2YgYSBub2RlIHBhY2thZ2UgdGhhdCBleHRlbmQgdGhlIENESyBmZWF0dXJlcy4gQ2FuIGJlIHNwZWNpZmllZCBtdWx0aXBsZSB0aW1lcycsIG5hcmdzOiAxIH0pXG4gICAgLm9wdGlvbigndHJhY2UnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ1ByaW50IHRyYWNlIGZvciBzdGFjayB3YXJuaW5ncycgfSlcbiAgICAub3B0aW9uKCdzdHJpY3QnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0RvIG5vdCBjb25zdHJ1Y3Qgc3RhY2tzIHdpdGggd2FybmluZ3MnIH0pXG4gICAgLm9wdGlvbignaWdub3JlLWVycm9ycycsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSwgZGVzYzogJ0lnbm9yZXMgc3ludGhlc2lzIGVycm9ycywgd2hpY2ggd2lsbCBsaWtlbHkgcHJvZHVjZSBhbiBpbnZhbGlkIG91dHB1dCcgfSlcbiAgICAub3B0aW9uKCdqc29uJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnaicsIGRlc2M6ICdVc2UgSlNPTiBvdXRwdXQgaW5zdGVhZCBvZiBZQU1MIHdoZW4gdGVtcGxhdGVzIGFyZSBwcmludGVkIHRvIFNURE9VVCcsIGRlZmF1bHQ6IGZhbHNlIH0pXG4gICAgLm9wdGlvbigndmVyYm9zZScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ3YnLCBkZXNjOiAnU2hvdyBkZWJ1ZyBsb2dzJywgZGVmYXVsdDogZmFsc2UgfSlcbiAgICAub3B0aW9uKCdwcm9maWxlJywgeyB0eXBlOiAnc3RyaW5nJywgZGVzYzogJ1VzZSB0aGUgaW5kaWNhdGVkIEFXUyBwcm9maWxlIGFzIHRoZSBkZWZhdWx0IGVudmlyb25tZW50JywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCdwcm94eScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdVc2UgdGhlIGluZGljYXRlZCBwcm94eS4gV2lsbCByZWFkIGZyb20gSFRUUFNfUFJPWFkgZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgbm90IHNwZWNpZmllZC4nLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ2VjMmNyZWRzJywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnaScsIGRlZmF1bHQ6IHVuZGVmaW5lZCwgZGVzYzogJ0ZvcmNlIHRyeWluZyB0byBmZXRjaCBFQzIgaW5zdGFuY2UgY3JlZGVudGlhbHMuIERlZmF1bHQ6IGd1ZXNzIEVDMiBpbnN0YW5jZSBzdGF0dXMuJyB9KVxuICAgIC5vcHRpb24oJ3ZlcnNpb24tcmVwb3J0aW5nJywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdJbmNsdWRlIHRoZSBcIkFXUzo6Q0RLOjpNZXRhZGF0YVwiIHJlc291cmNlIGluIHN5bnRoZXNpemVkIHRlbXBsYXRlcyAoZW5hYmxlZCBieSBkZWZhdWx0KScsIGRlZmF1bHQ6IHVuZGVmaW5lZCB9KVxuICAgIC5vcHRpb24oJ3BhdGgtbWV0YWRhdGEnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0luY2x1ZGUgXCJhd3M6Y2RrOnBhdGhcIiBDbG91ZEZvcm1hdGlvbiBtZXRhZGF0YSBmb3IgZWFjaCByZXNvdXJjZSAoZW5hYmxlZCBieSBkZWZhdWx0KScsIGRlZmF1bHQ6IHRydWUgfSlcbiAgICAub3B0aW9uKCdhc3NldC1tZXRhZGF0YScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnSW5jbHVkZSBcImF3czphc3NldDoqXCIgQ2xvdWRGb3JtYXRpb24gbWV0YWRhdGEgZm9yIHJlc291cmNlcyB0aGF0IHVzZXIgYXNzZXRzIChlbmFibGVkIGJ5IGRlZmF1bHQpJywgZGVmYXVsdDogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3JvbGUtYXJuJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdyJywgZGVzYzogJ0FSTiBvZiBSb2xlIHRvIHVzZSB3aGVuIGludm9raW5nIENsb3VkRm9ybWF0aW9uJywgZGVmYXVsdDogdW5kZWZpbmVkLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3Rvb2xraXQtc3RhY2stbmFtZScsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdUaGUgbmFtZSBvZiB0aGUgQ0RLIHRvb2xraXQgc3RhY2snLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgIC5vcHRpb24oJ3N0YWdpbmcnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0NvcHkgYXNzZXRzIHRvIHRoZSBvdXRwdXQgZGlyZWN0b3J5ICh1c2UgLS1uby1zdGFnaW5nIHRvIGRpc2FibGUsIG5lZWRlZCBmb3IgbG9jYWwgZGVidWdnaW5nIHRoZSBzb3VyY2UgZmlsZXMgd2l0aCBTQU0gQ0xJKScsIGRlZmF1bHQ6IHRydWUgfSlcbiAgICAub3B0aW9uKCdvdXRwdXQnLCB7IHR5cGU6ICdzdHJpbmcnLCBhbGlhczogJ28nLCBkZXNjOiAnRW1pdHMgdGhlIHN5bnRoZXNpemVkIGNsb3VkIGFzc2VtYmx5IGludG8gYSBkaXJlY3RvcnkgKGRlZmF1bHQ6IGNkay5vdXQpJywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAub3B0aW9uKCduby1jb2xvcicsIHsgdHlwZTogJ2Jvb2xlYW4nLCBkZXNjOiAnUmVtb3ZlcyBjb2xvcnMgYW5kIG90aGVyIHN0eWxlIGZyb20gY29uc29sZSBvdXRwdXQnLCBkZWZhdWx0OiBmYWxzZSB9KVxuICAgIC5jb21tYW5kKFsgJ2xpc3QgW1NUQUNLUy4uXScsICdscyBbU1RBQ0tTLi5dJyBdLCAnTGlzdHMgYWxsIHN0YWNrcyBpbiB0aGUgYXBwJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2xvbmcnLCB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UsIGFsaWFzOiAnbCcsIGRlc2M6ICdEaXNwbGF5IGVudmlyb25tZW50IGluZm9ybWF0aW9uIGZvciBlYWNoIHN0YWNrJyB9KSlcbiAgICAuY29tbWFuZChbICdzeW50aGVzaXplIFtTVEFDS1MuLl0nLCAnc3ludGggW1NUQUNLUy4uXScgXSwgJ1N5bnRoZXNpemVzIGFuZCBwcmludHMgdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGZvciB0aGlzIHN0YWNrJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2V4Y2x1c2l2ZWx5JywgeyB0eXBlOiAnYm9vbGVhbicsIGFsaWFzOiAnZScsIGRlc2M6ICdPbmx5IGRlcGxveSByZXF1ZXN0ZWQgc3RhY2tzLCBkb25cXCd0IGluY2x1ZGUgZGVwZW5kZW5jaWVzJyB9KSlcbiAgICAuY29tbWFuZCgnYm9vdHN0cmFwIFtFTlZJUk9OTUVOVFMuLl0nLCAnRGVwbG95cyB0aGUgQ0RLIHRvb2xraXQgc3RhY2sgaW50byBhbiBBV1MgZW52aXJvbm1lbnQnLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignYm9vdHN0cmFwLWJ1Y2tldC1uYW1lJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6IFsnYicsICd0b29sa2l0LWJ1Y2tldC1uYW1lJ10sIGRlc2M6ICdUaGUgbmFtZSBvZiB0aGUgQ0RLIHRvb2xraXQgYnVja2V0JywgZGVmYXVsdDogdW5kZWZpbmVkIH0pXG4gICAgICAub3B0aW9uKCdib290c3RyYXAta21zLWtleS1pZCcsIHsgdHlwZTogJ3N0cmluZycsIGRlc2M6ICdBV1MgS01TIG1hc3RlciBrZXkgSUQgdXNlZCBmb3IgdGhlIFNTRS1LTVMgZW5jcnlwdGlvbicsIGRlZmF1bHQ6IHVuZGVmaW5lZCB9KSlcbiAgICAuY29tbWFuZCgnZGVwbG95IFtTVEFDS1MuLl0nLCAnRGVwbG95cyB0aGUgc3RhY2socykgbmFtZWQgU1RBQ0tTIGludG8geW91ciBBV1MgYWNjb3VudCcsIHlhcmdzID0+IHlhcmdzXG4gICAgICAub3B0aW9uKCdidWlsZC1leGNsdWRlJywgeyB0eXBlOiAnYXJyYXknLCBhbGlhczogJ0UnLCBuYXJnczogMSwgZGVzYzogJ0RvIG5vdCByZWJ1aWxkIGFzc2V0IHdpdGggdGhlIGdpdmVuIElELiBDYW4gYmUgc3BlY2lmaWVkIG11bHRpcGxlIHRpbWVzLicsIGRlZmF1bHQ6IFtdIH0pXG4gICAgICAub3B0aW9uKCdleGNsdXNpdmVseScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2UnLCBkZXNjOiAnT25seSBkZXBsb3kgcmVxdWVzdGVkIHN0YWNrcywgZG9uXFwndCBpbmNsdWRlIGRlcGVuZGVuY2llcycgfSlcbiAgICAgIC5vcHRpb24oJ3JlcXVpcmUtYXBwcm92YWwnLCB7IHR5cGU6ICdzdHJpbmcnLCBjaG9pY2VzOiBbUmVxdWlyZUFwcHJvdmFsLk5ldmVyLCBSZXF1aXJlQXBwcm92YWwuQW55Q2hhbmdlLCBSZXF1aXJlQXBwcm92YWwuQnJvYWRlbmluZ10sIGRlc2M6ICdXaGF0IHNlY3VyaXR5LXNlbnNpdGl2ZSBjaGFuZ2VzIG5lZWQgbWFudWFsIGFwcHJvdmFsJyB9KVxuICAgICAgLm9wdGlvbignY2knLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0ZvcmNlIENJIGRldGVjdGlvbi4gVXNlIC0tbm8tY2kgdG8gZGlzYWJsZSBDSSBhdXRvZGV0ZWN0aW9uLicsIGRlZmF1bHQ6IHByb2Nlc3MuZW52LkNJICE9PSB1bmRlZmluZWQgfSlcbiAgICAgIC5vcHRpb24oJ3RhZ3MnLCB7IHR5cGU6ICdhcnJheScsIGFsaWFzOiAndCcsIGRlc2M6ICdUYWdzIHRvIGFkZCB0byB0aGUgc3RhY2sgKEtFWT1WQUxVRSknLCBuYXJnczogMSwgcmVxdWlyZXNBcmc6IHRydWUgfSkpXG4gICAgLmNvbW1hbmQoJ2Rlc3Ryb3kgW1NUQUNLUy4uXScsICdEZXN0cm95IHRoZSBzdGFjayhzKSBuYW1lZCBTVEFDS1MnLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignZXhjbHVzaXZlbHknLCB7IHR5cGU6ICdib29sZWFuJywgYWxpYXM6ICdlJywgZGVzYzogJ09ubHkgZGVwbG95IHJlcXVlc3RlZCBzdGFja3MsIGRvblxcJ3QgaW5jbHVkZSBkZXBlbmRlZXMnIH0pXG4gICAgICAub3B0aW9uKCdmb3JjZScsIHsgdHlwZTogJ2Jvb2xlYW4nLCBhbGlhczogJ2YnLCBkZXNjOiAnRG8gbm90IGFzayBmb3IgY29uZmlybWF0aW9uIGJlZm9yZSBkZXN0cm95aW5nIHRoZSBzdGFja3MnIH0pKVxuICAgIC5jb21tYW5kKCdkaWZmIFtTVEFDS1MuLl0nLCAnQ29tcGFyZXMgdGhlIHNwZWNpZmllZCBzdGFjayB3aXRoIHRoZSBkZXBsb3llZCBzdGFjayBvciBhIGxvY2FsIHRlbXBsYXRlIGZpbGUsIGFuZCByZXR1cm5zIHdpdGggc3RhdHVzIDEgaWYgYW55IGRpZmZlcmVuY2UgaXMgZm91bmQnLCB5YXJncyA9PiB5YXJnc1xuICAgICAgLm9wdGlvbignZXhjbHVzaXZlbHknLCB7IHR5cGU6ICdib29sZWFuJywgYWxpYXM6ICdlJywgZGVzYzogJ09ubHkgZGlmZiByZXF1ZXN0ZWQgc3RhY2tzLCBkb25cXCd0IGluY2x1ZGUgZGVwZW5kZW5jaWVzJyB9KVxuICAgICAgLm9wdGlvbignY29udGV4dC1saW5lcycsIHsgdHlwZTogJ251bWJlcicsIGRlc2M6ICdOdW1iZXIgb2YgY29udGV4dCBsaW5lcyB0byBpbmNsdWRlIGluIGFyYml0cmFyeSBKU09OIGRpZmYgcmVuZGVyaW5nJywgZGVmYXVsdDogMywgcmVxdWlyZXNBcmc6IHRydWUgfSlcbiAgICAgIC5vcHRpb24oJ3RlbXBsYXRlJywgeyB0eXBlOiAnc3RyaW5nJywgZGVzYzogJ1RoZSBwYXRoIHRvIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSB0byBjb21wYXJlIHdpdGgnLCByZXF1aXJlc0FyZzogdHJ1ZSB9KVxuICAgICAgLm9wdGlvbignc3RyaWN0JywgeyB0eXBlOiAnYm9vbGVhbicsIGRlc2M6ICdEbyBub3QgZmlsdGVyIG91dCBBV1M6OkNESzo6TWV0YWRhdGEgcmVzb3VyY2VzJywgZGVmYXVsdDogZmFsc2UgfSkpXG4gICAgLmNvbW1hbmQoJ21ldGFkYXRhIFtTVEFDS10nLCAnUmV0dXJucyBhbGwgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhY2snKVxuICAgIC5jb21tYW5kKCdpbml0IFtURU1QTEFURV0nLCAnQ3JlYXRlIGEgbmV3LCBlbXB0eSBDREsgcHJvamVjdCBmcm9tIGEgdGVtcGxhdGUuIEludm9rZWQgd2l0aG91dCBURU1QTEFURSwgdGhlIGFwcCB0ZW1wbGF0ZSB3aWxsIGJlIHVzZWQuJywgeWFyZ3MgPT4geWFyZ3NcbiAgICAgIC5vcHRpb24oJ2xhbmd1YWdlJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdsJywgZGVzYzogJ1RoZSBsYW5ndWFnZSB0byBiZSB1c2VkIGZvciB0aGUgbmV3IHByb2plY3QgKGRlZmF1bHQgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gfi8uY2RrLmpzb24pJywgY2hvaWNlczogaW5pdFRlbXBsYXRlTGFudWFnZXMgfSlcbiAgICAgIC5vcHRpb24oJ2xpc3QnLCB7IHR5cGU6ICdib29sZWFuJywgZGVzYzogJ0xpc3QgdGhlIGF2YWlsYWJsZSB0ZW1wbGF0ZXMnIH0pKVxuICAgIC5jb21tYW5kRGlyKCcuLi9saWIvY29tbWFuZHMnLCB7IGV4Y2x1ZGU6IC9eXy4qLyB9KVxuICAgIC52ZXJzaW9uKHZlcnNpb24uRElTUExBWV9WRVJTSU9OKVxuICAgIC5kZW1hbmRDb21tYW5kKDEsICcnKSAvLyBqdXN0IHByaW50IGhlbHBcbiAgICAuaGVscCgpXG4gICAgLmFsaWFzKCdoJywgJ2hlbHAnKVxuICAgIC5lcGlsb2d1ZShbXG4gICAgICAnSWYgeW91ciBhcHAgaGFzIGEgc2luZ2xlIHN0YWNrLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNwZWNpZnkgdGhlIHN0YWNrIG5hbWUnLFxuICAgICAgJ0lmIG9uZSBvZiBjZGsuanNvbiBvciB+Ly5jZGsuanNvbiBleGlzdHMsIG9wdGlvbnMgc3BlY2lmaWVkIHRoZXJlIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0cy4gU2V0dGluZ3MgaW4gY2RrLmpzb24gdGFrZSBwcmVjZWRlbmNlLidcbiAgICBdLmpvaW4oJ1xcblxcbicpKVxuICAgIC5hcmd2O1xufVxuXG5pZiAoIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG4gIGNvbG9ycy5kaXNhYmxlKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXRDb21tYW5kTGluZSgpIHtcbiAgY29uc3QgYXJndiA9IGF3YWl0IHBhcnNlQ29tbWFuZExpbmVBcmd1bWVudHMoKTtcbiAgaWYgKGFyZ3YudmVyYm9zZSkge1xuICAgIHNldFZlcmJvc2UoKTtcbiAgfVxuICBkZWJ1ZygnQ0RLIHRvb2xraXQgdmVyc2lvbjonLCB2ZXJzaW9uLkRJU1BMQVlfVkVSU0lPTik7XG4gIGRlYnVnKCdDb21tYW5kIGxpbmUgYXJndW1lbnRzOicsIGFyZ3YpO1xuXG4gIGNvbnN0IGF3cyA9IG5ldyBTREsoe1xuICAgIHByb2ZpbGU6IGFyZ3YucHJvZmlsZSxcbiAgICBwcm94eUFkZHJlc3M6IGFyZ3YucHJveHksXG4gICAgZWMyY3JlZHM6IGFyZ3YuZWMyY3JlZHMsXG4gIH0pO1xuICBjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb24oYXJndik7XG4gIGF3YWl0IGNvbmZpZ3VyYXRpb24ubG9hZCgpO1xuXG4gIGNvbnN0IHByb3Zpc2lvbmVyID0gbmV3IENsb3VkRm9ybWF0aW9uRGVwbG95bWVudFRhcmdldCh7IGF3cyB9KTtcblxuICBjb25zdCBhcHBTdGFja3MgPSBuZXcgQXBwU3RhY2tzKHtcbiAgICB2ZXJib3NlOiBhcmd2LnRyYWNlIHx8IGFyZ3YudmVyYm9zZSxcbiAgICBpZ25vcmVFcnJvcnM6IGFyZ3ZbJ2lnbm9yZS1lcnJvcnMnXSxcbiAgICBzdHJpY3Q6IGFyZ3Yuc3RyaWN0LFxuICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgYXdzLFxuICAgIHN5bnRoZXNpemVyOiBleGVjUHJvZ3JhbSxcbiAgfSk7XG5cbiAgLyoqIEZ1bmN0aW9uIHRvIGxvYWQgcGx1Zy1pbnMsIHVzaW5nIGNvbmZpZ3VyYXRpb25zIGFkZGl0aXZlbHkuICovXG4gIGZ1bmN0aW9uIGxvYWRQbHVnaW5zKC4uLnNldHRpbmdzOiBTZXR0aW5nc1tdKSB7XG4gICAgY29uc3QgbG9hZGVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IHBsdWdpbnM6IHN0cmluZ1tdID0gc291cmNlLmdldChbJ3BsdWdpbiddKSB8fCBbXTtcbiAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB0cnlSZXNvbHZlKHBsdWdpbik7XG4gICAgICAgIGlmIChsb2FkZWQuaGFzKHJlc29sdmVkKSkgeyBjb250aW51ZTsgfVxuICAgICAgICBkZWJ1ZyhgTG9hZGluZyBwbHVnLWluOiAke2NvbG9ycy5ncmVlbihwbHVnaW4pfSBmcm9tICR7Y29sb3JzLmJsdWUocmVzb2x2ZWQpfWApO1xuICAgICAgICBQbHVnaW5Ib3N0Lmluc3RhbmNlLmxvYWQocGx1Z2luKTtcbiAgICAgICAgbG9hZGVkLmFkZChyZXNvbHZlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJ5UmVzb2x2ZShwbHVnaW46IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZS5yZXNvbHZlKHBsdWdpbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKGBVbmFibGUgdG8gcmVzb2x2ZSBwbHVnaW4gJHtjb2xvcnMuZ3JlZW4ocGx1Z2luKX06ICR7ZS5zdGFja31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVzb2x2ZSBwbHVnLWluOiAke3BsdWdpbn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkUGx1Z2lucyhjb25maWd1cmF0aW9uLnNldHRpbmdzKTtcblxuICBjb25zdCBjbWQgPSBhcmd2Ll9bMF07XG5cbiAgLy8gQnVuZGxlIHVwIGdsb2JhbCBvYmplY3RzIHNvIHRoZSBjb21tYW5kcyBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIGNvbnN0IGNvbW1hbmRPcHRpb25zID0geyBhcmdzOiBhcmd2LCBhcHBTdGFja3MsIGNvbmZpZ3VyYXRpb24sIGF3cyB9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcmd2LmNvbW1hbmRIYW5kbGVyXG4gICAgICA/IGF3YWl0IChhcmd2LmNvbW1hbmRIYW5kbGVyIGFzIChvcHRzOiB0eXBlb2YgY29tbWFuZE9wdGlvbnMpID0+IGFueSkoY29tbWFuZE9wdGlvbnMpXG4gICAgICA6IGF3YWl0IG1haW4oY21kLCBhcmd2KTtcbiAgICBpZiAodHlwZW9mIHJldHVyblZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRvSnNvbk9yWWFtbChyZXR1cm5WYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgdmVyc2lvbi5kaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG1haW4oY29tbWFuZDogc3RyaW5nLCBhcmdzOiBhbnkpOiBQcm9taXNlPG51bWJlciB8IHN0cmluZyB8IHt9IHwgdm9pZD4ge1xuICAgIGNvbnN0IHRvb2xraXRTdGFja05hbWU6IHN0cmluZyA9IGNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndG9vbGtpdFN0YWNrTmFtZSddKSB8fCBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcblxuICAgIGlmICh0b29sa2l0U3RhY2tOYW1lICE9PSBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSkge1xuICAgICAgcHJpbnQoYFRvb2xraXQgc3RhY2s6ICR7Y29sb3JzLmJvbGQodG9vbGtpdFN0YWNrTmFtZSl9YCk7XG4gICAgfVxuXG4gICAgYXJncy5TVEFDS1MgPSBhcmdzLlNUQUNLUyB8fCBbXTtcbiAgICBhcmdzLkVOVklST05NRU5UUyA9IGFyZ3MuRU5WSVJPTk1FTlRTIHx8IFtdO1xuXG4gICAgY29uc3QgY2xpID0gbmV3IENka1Rvb2xraXQoeyBhcHBTdGFja3MsIHByb3Zpc2lvbmVyIH0pO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdscyc6XG4gICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaUxpc3QoYXJncy5TVEFDS1MsIHsgbG9uZzogYXJncy5sb25nIH0pO1xuXG4gICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaS5kaWZmKHtcbiAgICAgICAgICBzdGFja05hbWVzOiBhcmdzLlNUQUNLUyxcbiAgICAgICAgICBleGNsdXNpdmVseTogYXJncy5leGNsdXNpdmVseSxcbiAgICAgICAgICB0ZW1wbGF0ZVBhdGg6IGFyZ3MudGVtcGxhdGUsXG4gICAgICAgICAgc3RyaWN0OiBhcmdzLnN0cmljdCxcbiAgICAgICAgICBjb250ZXh0TGluZXM6IGFyZ3MuY29udGV4dExpbmVzXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdib290c3RyYXAnOlxuICAgICAgICByZXR1cm4gYXdhaXQgY2xpQm9vdHN0cmFwKGFyZ3MuRU5WSVJPTk1FTlRTLCB0b29sa2l0U3RhY2tOYW1lLCBhcmdzLnJvbGVBcm4sIHtcbiAgICAgICAgICBidWNrZXROYW1lOiBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3Rvb2xraXRCdWNrZXQnLCAnYnVja2V0TmFtZSddKSxcbiAgICAgICAgICBrbXNLZXlJZDogY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd0b29sa2l0QnVja2V0JywgJ2ttc0tleUlkJ10pLFxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnZGVwbG95JzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaS5kZXBsb3koe1xuICAgICAgICAgIHN0YWNrTmFtZXM6IGFyZ3MuU1RBQ0tTLFxuICAgICAgICAgIGV4Y2x1c2l2ZWx5OiBhcmdzLmV4Y2x1c2l2ZWx5LFxuICAgICAgICAgIHRvb2xraXRTdGFja05hbWUsXG4gICAgICAgICAgcm9sZUFybjogYXJncy5yb2xlQXJuLFxuICAgICAgICAgIHJlcXVpcmVBcHByb3ZhbDogY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydyZXF1aXJlQXBwcm92YWwnXSksXG4gICAgICAgICAgY2k6IGFyZ3MuY2ksXG4gICAgICAgICAgcmV1c2VBc3NldHM6IGFyZ3NbJ2J1aWxkLWV4Y2x1ZGUnXSxcbiAgICAgICAgICB0YWdzOiBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ3RhZ3MnXSksXG4gICAgICAgICAgc2RrOiBhd3MsXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaS5kZXN0cm95KHtcbiAgICAgICAgICBzdGFja05hbWVzOiBhcmdzLlNUQUNLUyxcbiAgICAgICAgICBleGNsdXNpdmVseTogYXJncy5leGNsdXNpdmVseSxcbiAgICAgICAgICBmb3JjZTogYXJncy5mb3JjZSxcbiAgICAgICAgICByb2xlQXJuOiBhcmdzLnJvbGVBcm4sXG4gICAgICAgICAgc2RrOiBhd3MsXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdzeW50aGVzaXplJzpcbiAgICAgIGNhc2UgJ3N5bnRoJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNsaVN5bnRoZXNpemUoYXJncy5TVEFDS1MsIGFyZ3MuZXhjbHVzaXZlbHkpO1xuXG4gICAgICBjYXNlICdtZXRhZGF0YSc6XG4gICAgICAgIHJldHVybiBhd2FpdCBjbGlNZXRhZGF0YShhd2FpdCBmaW5kU3RhY2soYXJncy5TVEFDSykpO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2xhbmd1YWdlJ10pO1xuICAgICAgICBpZiAoYXJncy5saXN0KSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHByaW50QXZhaWxhYmxlVGVtcGxhdGVzKGxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgY2xpSW5pdChhcmdzLlRFTVBMQVRFLCBsYW5ndWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlNZXRhZGF0YShzdGFja05hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHMgPSBhd2FpdCBhcHBTdGFja3Muc3ludGhlc2l6ZVN0YWNrKHN0YWNrTmFtZSk7XG4gICAgcmV0dXJuIHMubWFuaWZlc3QubWV0YWRhdGEgfHwge307XG4gIH1cblxuICAvKipcbiAgICogQm9vdHN0cmFwIHRoZSBDREsgVG9vbGtpdCBzdGFjayBpbiB0aGUgYWNjb3VudHMgdXNlZCBieSB0aGUgc3BlY2lmaWVkIHN0YWNrKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gZW52aXJvbm1lbnRHbG9icyBlbnZpcm9ubWVudCBuYW1lcyB0aGF0IG5lZWQgdG8gaGF2ZSB0b29sa2l0IHN1cHBvcnRcbiAgICogICAgICAgICAgICAgcHJvdmlzaW9uZWQsIGFzIGEgZ2xvYiBmaWx0ZXIuIElmIG5vbmUgaXMgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgIGFsbCBzdGFja3MgYXJlIGltcGxpY2l0bHkgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB0b29sa2l0U3RhY2tOYW1lIHRoZSBuYW1lIHRvIGJlIHVzZWQgZm9yIHRoZSBDREsgVG9vbGtpdCBzdGFjay5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGNsaUJvb3RzdHJhcChlbnZpcm9ubWVudEdsb2JzOiBzdHJpbmdbXSwgdG9vbGtpdFN0YWNrTmFtZTogc3RyaW5nLCByb2xlQXJuOiBzdHJpbmcgfCB1bmRlZmluZWQsIHByb3BzOiBCb290c3RyYXBFbnZpcm9ubWVudFByb3BzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVHdvIG1vZGVzIG9mIG9wZXJhdGlvbi5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuICctLWFwcCcgYXJndW1lbnQsIHdlIHNlbGVjdCB0aGUgZW52aXJvbm1lbnRzIGZyb20gdGhlIGFwcC4gT3RoZXJ3aXNlIHdlIGp1c3QgdGFrZSB0aGUgdXNlclxuICAgIC8vIGF0IHRoZWlyIHdvcmQgdGhhdCB0aGV5IGtub3cgdGhlIG5hbWUgb2YgdGhlIGVudmlyb25tZW50LlxuXG4gICAgY29uc3QgYXBwID0gY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydhcHAnXSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudHMgPSBhcHAgPyBhd2FpdCBnbG9iRW52aXJvbm1lbnRzRnJvbVN0YWNrcyhhcHBTdGFja3MsIGVudmlyb25tZW50R2xvYnMsIGF3cykgOiBlbnZpcm9ubWVudHNGcm9tRGVzY3JpcHRvcnMoZW52aXJvbm1lbnRHbG9icyk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbnZpcm9ubWVudHMubWFwKGFzeW5jIChlbnZpcm9ubWVudCkgPT4ge1xuICAgICAgc3VjY2VzcygnIOKPsyAgQm9vdHN0cmFwcGluZyBlbnZpcm9ubWVudCAlcy4uLicsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJvb3RzdHJhcEVudmlyb25tZW50KGVudmlyb25tZW50LCBhd3MsIHRvb2xraXRTdGFja05hbWUsIHJvbGVBcm4sIHByb3BzKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wID8gJyDinIUgIEVudmlyb25tZW50ICVzIGJvb3RzdHJhcHBlZCAobm8gY2hhbmdlcykuJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJyDinIUgIEVudmlyb25tZW50ICVzIGJvb3RzdHJhcHBlZC4nO1xuICAgICAgICBzdWNjZXNzKG1lc3NhZ2UsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoJyDinYwgIEVudmlyb25tZW50ICVzIGZhaWxlZCBib290c3RyYXBwaW5nOiAlcycsIGNvbG9ycy5ibHVlKGVudmlyb25tZW50Lm5hbWUpLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSB0aGUgZ2l2ZW4gc2V0IG9mIHN0YWNrcyAoY2FsbGVkIHdoZW4gdGhlIHVzZXIgcnVucyAnY2RrIHN5bnRoJylcbiAgICpcbiAgICogSU5QVVQ6IFN0YWNrIG5hbWVzIGNhbiBiZSBzdXBwbGllZCB1c2luZyBhIGdsb2IgZmlsdGVyLiBJZiBubyBzdGFja3MgYXJlXG4gICAqIGdpdmVuLCBhbGwgc3RhY2tzIGZyb20gdGhlIGFwcGxpY2F0aW9uIGFyZSBpbXBsaWN0bHkgc2VsZWN0ZWQuXG4gICAqXG4gICAqIE9VVFBVVDogSWYgbW9yZSB0aGFuIG9uZSBzdGFjayBlbmRzIHVwIGJlaW5nIHNlbGVjdGVkLCBhbiBvdXRwdXQgZGlyZWN0b3J5XG4gICAqIHNob3VsZCBiZSBzdXBwbGllZCwgd2hlcmUgdGhlIHRlbXBsYXRlcyB3aWxsIGJlIHdyaXR0ZW4uXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBjbGlTeW50aGVzaXplKHN0YWNrTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZWx5OiBib29sZWFuKTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBPbmx5IGF1dG9zZWxlY3QgZGVwZW5kZW5jaWVzIGlmIGl0IGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggdXNlciByZXF1ZXN0IG9yIG91dHB1dCBvcHRpb25zXG4gICAgY29uc3QgYXV0b1NlbGVjdERlcGVuZGVuY2llcyA9ICFleGNsdXNpdmVseTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3Moc3RhY2tOYW1lcywge1xuICAgICAgZXh0ZW5kOiBhdXRvU2VsZWN0RGVwZW5kZW5jaWVzID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbSA6IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3NcbiAgICB9KTtcblxuICAgIGFwcFN0YWNrcy5wcm9jZXNzTWV0YWRhdGEoc3RhY2tzKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgc3RhY2ssIHByaW50IGl0IHRvIFNURE9VVFxuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gc3RhY2tzWzBdLnRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYSBzbGlnaHQgaGFjazsgaW4gaW50ZWcgbW9kZSB3ZSBhbGxvdyBtdWx0aXBsZSBzdGFja3MgdG8gYmUgc3ludGhlc2l6ZWQgdG8gc3Rkb3V0IHNlcXVlbnRpYWxseS5cbiAgICAvLyBUaGlzIGlzIHRvIG1ha2UgaXQgc28gdGhhdCB3ZSBjYW4gc3VwcG9ydCBtdWx0aS1zdGFjayBpbnRlZyB0ZXN0IGV4cGVjdGF0aW9ucywgd2l0aG91dCBzbyBkcmFzdGljYWxseVxuICAgIC8vIGhhdmluZyB0byBjaGFuZ2UgdGhlIHN5bnRoZXNpcyBmb3JtYXQgdGhhdCB3ZSBoYXZlIHRvIHJlcnVuIGFsbCBpbnRlZyB0ZXN0cy5cbiAgICAvL1xuICAgIC8vIEJlY2F1c2UgdGhpcyBmZWF0dXJlIGlzIG5vdCB1c2VmdWwgdG8gY29uc3VtZXJzICh0aGUgb3V0cHV0IGlzIG1pc3NpbmdcbiAgICAvLyB0aGUgc3RhY2sgbmFtZXMpLCBpdCdzIG5vdCBleHBvc2VkIGFzIGEgQ0xJIGZsYWcuIEluc3RlYWQsIGl0J3MgaGlkZGVuXG4gICAgLy8gYmVoaW5kIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgIGNvbnN0IGlzSW50ZWdNb2RlID0gcHJvY2Vzcy5lbnYuQ0RLX0lOVEVHX01PREUgPT09ICcxJztcbiAgICBpZiAoaXNJbnRlZ01vZGUpIHtcbiAgICAgIHJldHVybiBzdGFja3MubWFwKHMgPT4gcy50ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gbm90IG91dHB1dHRpbmcgdGVtcGxhdGUgdG8gc3Rkb3V0LCBsZXQncyBleHBsYWluIHRoaW5ncyB0byB0aGUgdXNlciBhIGxpdHRsZSBiaXQuLi5cbiAgICBzdWNjZXNzKGBTdWNjZXNzZnVsbHkgc3ludGhlc2l6ZWQgdG8gJHtjb2xvcnMuYmx1ZShwYXRoLnJlc29sdmUoYXBwU3RhY2tzLmFzc2VtYmx5IS5kaXJlY3RvcnkpKX1gKTtcbiAgICBwcmludChgU3VwcGx5IGEgc3RhY2sgbmFtZSAoJHtzdGFja3MubWFwKHMgPT4gY29sb3JzLmdyZWVuKHMubmFtZSkpLmpvaW4oJywgJyl9KSB0byBkaXNwbGF5IGl0cyB0ZW1wbGF0ZS5gKTtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbGlMaXN0KHNlbGVjdG9yczogc3RyaW5nW10sIG9wdGlvbnM6IHsgbG9uZz86IGJvb2xlYW4gfSA9IHsgfSkge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3Moc2VsZWN0b3JzLCB7IGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3MgfSk7XG5cbiAgICAvLyBpZiB3ZSBhcmUgaW4gXCJsb25nXCIgbW9kZSwgZW1pdCB0aGUgYXJyYXkgYXMtaXMgKEpTT04vWUFNTClcbiAgICBpZiAob3B0aW9ucy5sb25nKSB7XG4gICAgICBjb25zdCBsb25nID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsb25nLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHN0YWNrLm5hbWUsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHN0YWNrLmVudmlyb25tZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvbmc7IC8vIHdpbGwgYmUgWUFNTCBmb3JtYXR0ZWQgb3V0cHV0XG4gICAgfVxuXG4gICAgLy8ganVzdCBwcmludCBzdGFjayBuYW1lc1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBkYXRhKHN0YWNrLm5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiAwOyAvLyBleGl0LWNvZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaCBhIHNpbmdsZSBzdGFjayBmcm9tIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBzdGFja3NcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGZpbmRTdGFjayhuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFwcFN0YWNrcy5zZWxlY3RTdGFja3MoW25hbWVdLCB7XG4gICAgICBleHRlbmQ6IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5Ob25lXG4gICAgfSk7XG5cbiAgICAvLyBDb3VsZCBoYXZlIGJlZW4gYSBnbG9iIHNvIGNoZWNrIHRoYXQgd2UgZXZhbHVhdGVkIHRvIGV4YWN0bHkgb25lXG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgY29tbWFuZCByZXF1aXJlcyBleGFjdGx5IG9uZSBzdGFjayBhbmQgd2UgbWF0Y2hlZCBtb3JlIHRoYW4gb25lOiAke3N0YWNrcy5tYXAoeCA9PiB4Lm5hbWUpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3NbMF0ubmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSnNvbk9yWWFtbChvYmplY3Q6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVN0cnVjdHVyZShvYmplY3QsIGFyZ3YuanNvbik7XG4gIH1cbn1cblxuaW5pdENvbW1hbmRMaW5lKClcbiAgLnRoZW4odmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCh2YWx1ZSk7XG4gICAgfVxuICB9KVxuICAuY2F0Y2goZXJyID0+IHtcbiAgICBlcnJvcihlcnIubWVzc2FnZSk7XG4gICAgZGVidWcoZXJyLnN0YWNrKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH0pO1xuIl19